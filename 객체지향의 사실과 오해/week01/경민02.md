# 이상한 나라의 객체

## 객체지향과 인지 능력

> 객체란  
> 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤것

- 물리적인 경계를 지닌 구체적인 사물 = 길을 걷는 사람들, 모니터, 책상 등
- 추상적인 사물 = 오늘, 어제의 주문내역, 출금과 입금 계좌 등

객체지향

- 현실 세계 모방(X)
- 객체지향 현실 세계를 기반으로 새로운 세계 창조(O)

## 객체, 그리고 이상한 나라

앨리스 객체

- 상태 : 특정 시점의 앨리스의 키, 앨리스의 위치
- 행동 : 앨리스의 키를 변화시킴

**상태를 결정**하는 것 = `행동`  
**행동의 결과를 결정**하는 것 = `상태`

즉, 행동의 결과는 앨리스의 상태에 의존적  
행동의 결과는 상태로 설명할 수 있다.

i.g.)

- 앨리스의 키(상태)에 따라 문을 통과(행동) 할 수 있느냐 없느냐가 결정됨

---

어떤 행동의 성공여부는 이전 행동의 결과(상태) 의해 영향을 받을 수 있음  
즉, 행동 간의 순서는 중요.

i.g)

- 문을 통과(행동) 하는데에 성공하면 앨리스는 정원(상태)에, 실패하면 앨리스는 여전히 통로에

---

앨리스는 상태가 변경되어도 앨리스다.  
= 앨리스는 어떤 상태에 있더라도 유일하게 식별이 가능하다.

---

## 객체, 그리고 소프트웨어 나라

> 객체  
> 상태(state) + 행동(behavior) + 식별자(identity)

```
객체란 식별 가능한 개체 또는 사물이다
객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도,
시간처럼 추상적인 개념일 수도.
객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다.
```

### 상태

상태는 왜 필요한가?

행동의 결과를 예측하기 위해서는 과거에 어떤 행동을 했는지 살펴본다.  
그러나, 모든 행동의 이력을 판단하기 어렵다.

따라서 이를 모두 설명하지 않고도 행동의 결과를 쉽게 예측하기 위해 상태는 필요하다.

---

**프로퍼티**

> 객체의 상태를 구성하는 모든 특징  
> 링크(link) + 속성(attribute)

프로퍼티 → 일반적으로 변경되지 않음  
프로퍼티 **값** → 시간이 흐름에 따라 변경됨

숫자, 문자열, 양, 속도, 시간, 날짜, 참/거짓 같은 단순한 값들은 객체가 아니다.

왜?  
그 자체로 독립적인 의미를 가지기 보다  
다른 객체의 특성을 표현하는데에 사용되기 때문

값이 아니라 객체를 사용해 다른 객체의 상태를 표현할 수도 있다.

i.g. 음료를 들고 있는 앨리스를 표현하기 위해 음료 객체가 필요

```
객체 앨리스 {
    키 = 130cm
    위치 = "통로"
    음료
}

음료 {
    양 = 0.5L
}
```

---

**링크(link)**

- 객체와 객체 사이의 의미있는 연결
- 한 객체가 다른 객체의 식별자를 알고 있음
- 링크가 존재해야 요청 주고받기 가능(= 메시지 주고받기)

**속성(attribute)**

- 객체를 구성하는 단순한 값

```
상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로
객체의 구조적 특징을 표현한다.
객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티값으로 표현된다.
객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.
```

객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장한다 = 객체의 자율성

### 행동

객체는 협력에 참여하는 과정에서 자기 자신의 상태뿐만 아니라
**다른 객체의 상태 변경을 유발** 할 수도 있다.
(다른 객체의 상태를 직접 변경하는 것과는 다른 개념이라고 이해해야 하는 듯하다.)

```
행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다.
행동의 결과로 객체는 자신의 상태를 변경하거나
다른 객체에게 메시지를 전달할 수 있다.
객체는 행동을 통해 다른 객체와 협력에 참여하므로 행동은 외부에서 가시적이어야 한다.
```

**상태 캡슐화**

> 메시지 송신자는 메시지 수신자의 상태 변경에 대해서 전혀 알지 못한다.

모든 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다.

객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다.  
객체가 외부에 노출하는 것은 행동뿐.

앨리스에게 dringBeverage()라는 메시지를 전달한 주체는  
이 메시지의 결과로 앨리스의 키가 줄어드는지 커지는지 알 수 없다.

### 식별자

> 객체를 서로 구별할 수 있는 특정한 프로퍼티

단순한 값은 식별자를 가지지 않는다.  
숫자, 문자열, 날짜, 시간, 금액 등과 같이 변하지 않는 양을 모델링한다.  
값의 상태는 변하지 않기 때문에 불변 상태라고 한다.  
값의 경우 두 인스턴스의 상태가 같다면 두 인스턴스를 같은 것으로 판단한다.

(이 개념이 너무 이해가 안가서 지피티랑 대화한 내용 정리해서 추가)

<details>
<summary>값과 변수</summary>

내가 이해가 가지 않은 부분 :

값의 상태가 변하지 않는 불변 상태라고 하는데

`int a = 1;` 이 있다고 가정해보면  
`a = 2;`하고 변할 수 있는게 아닌가? 라고 생각했음

지피티왈 여기서 a는 `변수`임  
값은 `1` 그 자체를 의미함  
변수는 그 값을 담는 그릇(=참조, 주소)가 된다.

1은 1인 상태가 절대 변하지 않기 때문에 1 = 1이 성립하게 된다.

</details>

---

**동등성(equality)**

> 상태를 이용해 두 값이 같은지 판단할 수 있는 성질

객체는 시간에 따라 변경되는 상태를 가지고 있고  
상태는 행동을 통해 변경될 수 있다.

따라서 객체는 가변 상태를 가진다고 말한다.

객체는 완전히 동일한 상태를 가지고 있더라도 별개의 객체가 된다.

**동일성(identical)**

> 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질

예를 들어 age = 10인 김경민과  
age = 27인 김경민은 상태가 다르지만
동일 인물로 판단 될 수 있는 일종의 식별자를 가지고 있기 때문에
같은 객체라고 판단할 수 있다...

```
식별자란 어떤 객체를 다른 객체와 구분하는데 사용하는 객체의 프로퍼티다.
값은 식별자를 가지지 않기 때문에
상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교한다.
객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.
```

value type vs reference type

- int, double, boolean 이런 값들은 원시 타입(primitive type) 또는 value type이라고 불린다.
- `int a = 1;` 과 같은 경우 a라는 이름의 메모리 공간에 jvm `스택 영역`에 생성된다.

---

- 참조객체(reference object) 또는 엔티티(entity)는 식별자를 지닌 전통적 의미의 객체를 가리키는 용어
- reference type의 경우 `스택 영역`에는 참조값만 있고, 실제 값은 `힙 영역`에 존재한다.

<details>
<summary>java의 Wrapper Class</summary>
*공부하다가 개인적으로 생각이 나서 정리해본 내용*

원시 타입은 객체가 아니라 값 그자체이기 때문에

- 메서드를 가질 수 없음
- 제너릭 같은 객체 기반 기능에 사용할 수 없음
  그렇기 때문에 객체로 다뤄야할 필요성이 생김  
  이를 위해 등장한 것이 Wrapper Class이다.

```java
int a = 10;
// a는 그냥 값 -> 메서드 불가

Integer b = Integer.valueOf(10);
// b는 객체 -> 메서드 사용 가능
int c = b.intValue(); // 다시 원시로 변환 가능

List<int> list = new ArrayList<>(); // ❌ 불가능
List<Integer> list = new ArrayList<>(); // ✅ 래퍼 덕분에 가능
```

java 5부터 원시값과 래퍼 객체 간의 오토박싱/언박싱 기능을 지원함

```java
Integer x = Integer.valueOf(5); // 박싱
int y = x.intValue();           // 언박싱
//자동변환의 경우 아래와 같다.
Integer x = 5; // 자동 박싱
int y = x;     // 자동 언박싱
```

</details>

## 행동이 상태를 결정한다

상태를 중심으로 객체를 바라보면 안된다. 왜?

- 상태를 먼저 결정할 경우 캡슐화 저해
- 객체를 협력자가 아닌 고립된 섬
- 객체의 재사용성 저하

객체지향 설계는 애플리케이션에 필요한 협력을 생각하고  
협력에 참여하는 데 필요한 행동을 생각한 후  
행동을 수행할 객체를 선택하는 방식으로 수행된다.

어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도 해야한다
(책임-주도 설계 : Responsibility-Drive Design, RDD)

## 은유와 객체

객체지향은 현실 세계의 모방이 아니다.

현실과 소프트웨어 객체의 차이는?  
현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 **능동적**으로 변한다.

레베카 워프스브록은 이러한 소프트웨어 객체의 특징을 의인화라고 부른다.

현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 **은유**다.  
은유의 본질은 한 종류의 사물을 다른 종류의 사물 관점에서 이해하고 경험
