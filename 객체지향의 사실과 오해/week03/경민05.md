# 책임과 메시지

## 자율적인 책임

`자율적인 객체`란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체  
`책임`이란 요청을 처리하기 위해 객체가 수행하는 행동

협력에 참여하는 객체가 얼마나 자율적인가? = 전체 애플리케이션의 품질

객체가 어떻게(how)가 아니라 무엇(what)을 해야하는가가 자율적인것임

## 메시지와 메서드

### 메시지

**메시지-전송** : 객체의 행동을 유발하는 행위

왕 → 모자장수 : 증언하라

- 증언하라 : 메시지 이름(message name)
- 장소, 시간 : 메시지 인자(argument) - 추가정보
  예) `모자장수.증언하라(어제, 왕국)`

외부의 객체 = 메시지에 관해서만 볼 수 있음
객체 내부 = 볼 수 없음, 수행할 객체가 자율적으로 선택함

### 메서드

왕이 전송한 메시지를 처리하기 위해 모자 장수가 내부적으로 선택하는 증언 방법이 **`메서드`**다.  
객체지향 프로그래밍 언어에서 메서드는 클래스 안에 포함된 `함수` 또는 `프로시저`를 통해 구현된다.

**함수(Function) vs 프로시저(Procedure)**
| 구분 | 함수(Function) | 프로시저(Procedure) |
|------|----------------|--------------------|
| **정의** | 값을 반환하는 코드 블록 | 값을 반환하지 않고 동작만 수행하는 코드 블록 |
| **반환값** | 반드시 반환값이 있음 | 없음 (`void`로 표현) |
| **용도** | 계산, 처리 후 결과 제공 | 처리/행위 수행, 출력 등 |
| **대표 언어** | Java, C++, Pascal, Ada, PL/SQL | Pascal, Ada, PL/SQL, C++ (`void`) |
| **객체지향에서 표현** | **메서드**로 구현, 반환값이 있음 | **메서드**로 구현, 반환값 없음 (`void`) |
| **예시 (자바)** | `int add(int a, int b) { return a+b; }` | `void printResult(int result) { System.out.println(result); }` |

---

1. **메서드(Method) = 클래스 안에 정의된 함수/프로시저**

   - 클래스의 행위(behavior)를 정의
   - 외부에서 메시지(message)를 보내 호출 가능

2. **함수형 메서드**

   - 특정 입력에 대해 값을 반환
   - 예: `BankAccount.getBalance()`

3. **프로시저형 메서드**
   - 입력만 받고, 내부 동작 수행 (상태 변경, 출력 등)
   - 예: `BankAccount.deposit(amount)`

### 다형성

서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다.  
기본적으로 다형성은 동일한 역할을 수행할 수 있는 객체들 사이에서 **대체 가능성**을 의미한다.  
다형성은 수신자의 종류를 **캡슐화**한다.

송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도를 낮춤으로써 달성

### 유연하고 확장 가능하고 재사용성이 높은 협력의 의미

송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실이 왜 설계의 품질에 영향을 미치는가?

1. 협력 유연
   - 송신자는 수신자가 다른 타입의 누군가로 대체 되어도 상관없다
   - 예를들어 `OrderService` 라는게 `PayService`인터페이스를 부른다면 `PayService`의 구현체인 `KakaoPayServcieImpl`, `CreditCardPaySerivceImpl` 등등 은 몰라도됨
2. 협력이 수행되는 방식 확장
   - 송신자에게 영향 없이 수신자를 교체할 수 있기 때문에 협력을 하는 구체적인 수행 방식을 쉽게 수정할 수 있다.
   - 예를 들어 `SamsungPayServiceImpl`이 추가되더라도 `OrderSerivce`는 변경되지 않음
3. 협력이 수행되는 방식 재사용
   - 예를 들어 `OrderService`든 `SubscriptionService`든 `PayService`를 재사용할 수 있음

## 메시지를 따라라

### What/Who사이클

책임-주도 설계의 핵심 = 어떤 행위가 필요한지를 먼저 결정하고 행위를 수행할 객체를 결정  
이 과정을 **What/Who 사이클**이라고 함  
여기서 **어떤 행위** = 메시지가 됨

메시지를 먼저 결정함으로써 객체의 인터페이스를 발견할 수 있다

### 묻지 말고 시켜라

메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계 방식은  
객체가 외부에 제공하는 인터페이스가 `독특한 스타일`을 따르게 한다.
이 스타일이 **묻지 말고 시켜라** 스타일 또는 **데메테르 법칙**이라고 한다.

객체는 다른 객체의 상태를 묻지 말아야 한다.  
메시지를 전송하기 이전에 객체가 가져야 하는 상태에 대한 고민을 하면 안된다.

## 객체 인터페이스

### 인터페이스

사람이건 사물이건 세계에 존재하는 그 어떤 대상과 상호작용 하고 싶다면 그 대상이 제공하는 인터페이스 사용법을 익혀야한다.

**인터페이스 특징**

1. 인터페이스 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 대상을 조작하거나 의사를 전달할 수 있다.
2. 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
3. 대상이 변경되더라도 동일한 인터페이스를 제공하기만 한다면 아무런 문제 없이 상호작용 할 수 있다.

### 공용 인터페이스

객체지향에서는 객체가 자기 자신에게 메시지를 전달하는 경우도 있다.  
그런 내부 사적 인터페이스와 구분하기 위해  
외부에 공개된 인터페이스를 `공용 인터페이스`라고 한다.

## 인터페이스와 구현의 분리

### 객체의 관점에서 생각하는 방법

- 추상적인 인터페이스
  - 떠오르는 기억을 시간 순서대로 재구성하라(x)
  - 증언하라(o)
- 최소 인터페이스
  - 외부에서 사용할 필요가 없는 이넡페이스는 노출x

### 구현 / 인터페이스와 구현의 분리 원칙

객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것 = 구현

소프트웨어는 항상 변경되기 때문에 객체의 내부 구현을 변경에 대한 안전 지대로 만들어 공용 인터페이스와 분리

### 캡슐화

- 상태와 행위의 캡슐화
  - 프로그래밍에서 상태는 주로 데이터, 행동은 프로세스
  - 하지만 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀로 묶음
  - (구체적의 필드 및 메소드 은닉(=캡슐화) 이기 때문에 아마 정보은닉 중 하나가 캡슐화가 아닐까?)
- 사적인 비밀의 캡슐화
  - 캡슐화를 통해 변경이 빈번하게 일어나는 불안정한 비밀을 안정적인 인터페이스 뒤로 숨기기

## 책임의 자율성이 협력의 품질을 결정한다

1. 자율적인 책임은 협력을 단순하게 만든다

- 세부적인 사항을 무시하고 의도를 드러내는 하나의 문장으로 표현 = 책임이 적절하게 `추상화`

2. 자율적인 책임은 외부와 내부를 명확하게 분리한다
3. 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다

- 변경의 파급효과가 객체 내부로 `캡슐화` 되기 때문이 두 객체간의 `결합도`가 낮아진다.

4. 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다

- 설계가 유연해지고 `재사용성`이 높아진다.

5. 객체의 역할을 이해하기 쉬워진다.

- 동일한 목적을 달성하는 강하게 연관된 책임으로 구성된 객체는 `응집도`가 높은 상태를 유지한다.
