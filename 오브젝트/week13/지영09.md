# 9장.유연한 설계
## 1.개방-폐세 원칙(OCP)
OCP
- sw 객체(클래스, 모듈, 함수)는 ```확장```에 대해 열려 있어야 하고, ```수정```에 대해서는 닫혀 있어야 한다.
  - 확장: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 ```동작```을 추가해서 애플리케이션의 기능을 확장
  - 수정: 기존 ```코드```를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경
- 유연한 설계란 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장하는 설계
- 컴파일타임 의존성을 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조
<img width="776" height="260" alt="image" src="https://github.com/user-attachments/assets/42060951-efcb-4b41-9ec6-5a6d8a1d5bbf" />

### 추상화가 핵심이다
- 추상화르 통해 핵심적인 부분만 의존하도록 해 문맥이 변하더라도 바뀌지 않음
- 문맥에 따라 적합한 기능을 구체화하면 된다.

## 2.생성 사용 분리  
sw 시스템
- 시작 단계(응용 프로그램 객체를 제작하고 의존성을 서로 ```연결```)
- 실행 단계(시작 단계 이후)

### FACTORY 추가하기
- 생성과 사용 분리를 위해 객체 생성에 특화된 객체: Factory
- Factroy를 사용하면 Client는 오직 사용과 관련한 책임만 가지고 생성과 관련된 어떤 지식도 가지지 않을 수 있음

### 순수한 가공물에게 책임 할당하기
PURE FABRICATION(순수한 가공물): 도메인과 무관한 인공적인 객체를 

시스템을 객체로 분해
- 표현적 분해(representational decompostion)
  - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해
  - 객체지향 설계를 위한 기본적인 접근법
  - 모든 책임을 도메인 객체에 할당하면 캡슐화가 위반
  - 설계자가 임의로 만들어낸 가공의 객체에 책임을 할당하여 문제를 해결
- 행위적 분해(behavioral decompostion):
  - 특정한 행동을 표현하기 위해 시스템을 분해
  - 어떤 행동을 책임질 도메인이 존재하지 않는다면 PURE FABRICATION을 추가하고 책임을 할당

## 3.의존성 주입(DI)
의존성 주입이란 하나의 객체가 다른 객체를 필요로 할 때 필요한 객체를 내부에서 직접 만드는 것이 아닌 외부에서 필요한 객체를 만들고 이를 주입받는 형태

의존성을 주입 받는 방법
- 생성자 주입(constructor injection):객체를 생성하는 시점에 생성자를 통한 의존성 해결
- setter 주입(setter injection): 객체를 생성 후 setter 메서드를 통해 의존성을 주입 받는 방법, 이는 불변성을 가지지 못하므로 취약
- 메서드 주입(method injection): 메서드 실행 시 인자를 통해 주입 받는 방법

## 4.의존성 역전 원칙
추상화와 의존성 역전
- 만일, OTT 객체가 Action Genre 라는 구체 타입에 의존시, 결합도가 높아지고 재사용성 및 유연성이 저해
- 하위 추상화 레벨인 Action Gnere 를 의존으로, 상위객체가 → 하위객체의 영향을 받는 구조
- 따라서, 의존성 역전 원칙(DIP)를 통해 추상화에 의존하도록 한다
- 상위 수준 → 하위 수준이 아닌, 하위 수준 → 상위 수준을 의존하는 구조여야 한다.

## 5.유연성에 대한 조언
유연한 설계
- 유연하고 재사용 가능한 설계가 항상 옳지 않음
- 해당 설계의 또다른 의미는 복잡한 설계임
- 따라서 불필요한 유연성을 통해 복잡함을 증대시키지 말고 필요할 때 변경해야 함

협력과 책임이 중요
- 설계에 핵심은 ```역할, 책임, 협력 ```을 규정하는 것
- 잘못된 설계는 역할과 책임을 규정하기 전 객체 생성등 필요하지 않는것에 집중하게 됨
  - 대표적인 케이스인 Singleton
