# 08.의존성 관리하기
- 응집도 높은 객체(책임의 초점이 명확하고 한 가지 일만 잘하는 객체
- 협력을 위해서는 의존성이 필요하지만 과도한 협력은 설계를 곤경에 빠트린다.
  
## 1.의존성 이해하기
- 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

### 의존성 전이(transitive dependency)
- 직접 의존성(direct dependency)
- 간접 의존성(indirect dependecy)

### 런타임 의존성과 컴파일타임 의존성
- 런타임 의존성(run-time dependecy)
  - 애플리케이션 실행 시점
  - 객체 사이의 의존성
- 컴파일 의존성(compile-time dependency)
  - 컴파일 시점 or 코드의 구조를 의미
  - 클래스 사이의 의존성
 
### 의종성 해결하기
의존성 해결: 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
1. 객체를 생성한는 시점에 생성자를 통해 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
3. 메서드 실행 시 인자를 이용해 의존성 해결

## 2. 유연한 설계

### 의존성과 결합도
의존성은 객체들의 협력을 가능하게 만드는 매개체라는 관점에서는 바람직하지만 의존성이 과하면 문제가 된다.

바람직한 의존성(재사용성)
- 느슨한 결합도(loose coupling) or 약한 결합도(weak coupling): 바람직한 의존성
- 단단한 결합도(tight coupling) or 강한 결합도(string coupling) : 바람직하지 않은 의존성

### 자식이 결합을 낳는다
- A와 B객체 사이에서 서로의 정보를 많이 알수록 결합도는 강해지며, 적을수록 약해짐
- 결국 지식의 양이 결합도를 결정하며, 이를 위한 효과적인 방법인 추상화

### 추상화에 의존하라
추상화: 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 국복하는 방법
</br>의존하는 대상이 추상적일수록 결합도는 더 낮아진다.
</br>아래쪽으로 갈수록 클라이언트가 알아야 하는 지식의 양이 적어지기 때문에 결합도가 느슨해진다.
- 구체 클래스 의존성(concrete class dependency)
- 추상 클래스 의존성(abstract class dependency)
- 인터페이스 의존성(interface dependency)

### 명시적인 의존성
의존성을 퍼블릭 인터페이스로 노출할지, 내부 구현에 노출할지에 따라 의존성의 종류가 변경된다
- 명시적 의존성(explicit dependency)
  - 퍼블릭 인터페이스에 노출되어 외부에서 사용할 때 해당 객체의 의존성을 명확하게 파악 가능
- 숨겨진 의존성(hidden dependency)
  - 퍼블릭 인터페이스에 표현되지 않는 의존성으로 내부 구현을 보지 않는한 파악 불가
  - ex.) A객체가 B객체에 의존할 때 다음과 같이 코드로 되어 있는 경우

### new는 해롭다
- new 연산자를 사용하기 위헤서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도가 높아진다.
- new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스와 생성자를 호출해야 하는지도 알아야 한다. 따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.
  
