# 의존성 관리하기
## 의존성 이해하기
### 변경과 의존성
- 실행 시점의 의존성 : 의존하는 객체가 동작하기 위해서 실행 시에 의존 대상 객체가 반드시 존재해야한다.
- 구현 시점의 의존성 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

```java
import java.time.LocalTime;

public class PeriodCondition implements DiscountCondition {

    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;
    
    ...
    
    public boolean isSatisfiedBy (Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
            startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
            endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```
실행 시점에 PeriodCondition 인스턴스가 정상 동작하려면 Screening 인스턴스가 존재해야한다.  
이런 경우 PeriodCondition은 Screening에 의존성을 가지는 것이다.

### 의존성 전이
Screening이 Movie, LocalDateTime, Customer에 의존하고 있기 때문에  
PeriodCondition이 Screening에 의존할 경우 Screening이 의존하는 대상에 대해서도 자동적으로 의존한다.  
즉, Screening의 의존성이 PeriodCondition으로 전파된다는 것.

의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다.
Screening이 내부 구현 캡슐화를 잘 하고 있다면 변경이 전파되진 않는다.

- 직접 의존성 : PeriodCondition이 Screening에 의존하듯 코드에 명시적으로 의존
- 간접 의존성 : 의존성 전이에 의해 전파된 경우. (코드안에 명시적으로 나타나지 x)

### 런타임 의존성과 컴파일 타임 의존성
지금까지 책에서 나왔듯 Movie는 DiscountPolicy라는 인터페이스에 의존한다.  
하지만 실질적으로 Movie가 할인 정책을 이용하기 위해서는
AmountDiscountPolicy, PercentDiscountPolicy와 같은 인터페이스 구현체들과 협력해야한다.  
코드 작성 시점의 Movie는 이 구현체들에 대해서 모르지만  
실행 시점의 Movie는 이 두 인스턴스와 협력할 수 있다.

### 의존성 해결하기
컴파일 의존성은 구체적인 런타임 의존성으로 대체되어야한다.  
컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 **의존성 해결** 이라고 부른다.  

**객체 생성 시점에 생성자를 통해 의존성 해결**
```java
Movie avatar = new Movie ("아바타". Duration.ofTimes(120), Money.wons(10000), new AmountDiscountPolicy(....));
```
**객체 생성 후 Setter 메서드를 통해 의존성 해결**
```java
Movie avatar = new Movie(...);
avatar.setDiscountPolicy(new AmountDiscountPolicy());
```
**메서드 실행 시 인자를 이용해 의존성 해결**
```java
public class Movie {
    public Money calculateMovieFee(Screening screening, DiscountPolicy discountPolicy) {...}
}
```

Setter 방식의 경우 실행 시점에 의존 대상을 변경할 수 있기 때문에 유연하다는 장점이 있지만  
의존 대상을 지정하기 전까지 객체의 상태가 불완전할 수 있다는 단점이 있다.

## 유연한 설계
바람직한 의존성이란? 재사용성과 관련이 있다.  
어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못 하다.  
의런 바람직한 의존성과 그렇지 못한 의존성을 용어로 나타내면 **결합도**가 된다.

### 명시적 의존성
생성자 방식으로 선언된 의존성의 경우
Movie가 DiscountPolicy에 의존한다는 사실을 Movie의 퍼블릭 인터페이스에 드러낸다.  
이런 경우를 명시적인 의존성이라고 한다.

하지만 Movie 내부에서 AmountPolicy의 인터페이스를 직접 생성하는 방식은 Movie가 DiscountPolicy에 의존한다는 사실을 숨긴다.  
이를 숨겨진 의존성이라고 한다.

의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴 볼 수 밖에 없다.  
따라서 의존성은 명시적으로 표현되어야 한다.

### new는 해롭다
결합도 측면에서 new가 해로운 이유
- new 연산자를 사용하기 위해서는 구체적인 클래스 이름을 직접 기술해야한다. 따라서 추상화가 아닌 구체 클래스에 의존할 수 밖에 없다. 
- new 연산자는 어떤 인자를 이용해 클래스의 생성자를 호출해야하는지도 알아야한다.

Movie가 생성자를 통해 DiscountPolicy를 전달받지 않고 직접 new를 이용해서 생성하면  
DiscountPolicy를 생성하기 위해 필요한 인자 모두에 의존할 수 밖에 없다.

그렇다면 누가 이 AmountDicsountPolicy를 생성해서 넘겨줄 것인가?  
Movie를 호출하는 클라이언트에게 생성의 책임을 넘기고  
Movie는 인스턴스를 사용하는 책임만 남는다.





