# 08/의존성 관리하기
## 1) 의존성 이해하기
- 의존성
  - 두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미
  - 어떤 객체가 협력하기 위해 다른 객체를 피룡로 할 때 두 객체 사이에 의존성이 존재
  - 의존성은 방향성을 가지며 항상 단방향
  - 의존성은 변경에 의한 영향의 전파 가능성을 암시
  - -> 의존성은 함께 변경될 수 있는 가능성을 의미


- 의존성 전이
  - A -> B에 의존, B -> C에 의존할 경우 A -> C에 의존하게 된다는 의미
  - 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라짐
  - -> 의존성 전이는 변경에 의해 영향이 널리 전파될 수도 있다는 경고


- 런타임 의존성
  - 런타임 : 애플리케이션이 실행되는 시점
  - 런타임 의존성 : 객체 사이의 의존성


- 컴파일타임 의존성
  - 컴파일타임 : 일반적으로 작성된 코드를 컴파일하는 시점이지만, 여기서는 코드 그 자체를 가리킴
  - 컴파일타임 의존성 : 클래스 사이의 의존성  

-> 런타임 의존성과 컴파일타임 의존성이 다를 수 있으며 유연하고 확장 가능한 설계를 만들기 위해서는 컴파일타임 의존성과 런타임 의존성이 달라야 함  


- 컨텍스트 독립성
  - 클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안됨. 구체적인 클래스를 알수록 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문. 강하게 결합될수록 다른 문맥에서는 사용하기 더 어려워짐
  - 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이루어져 있다면 다른 문맥에서 재사용하기가 더 수월해짐


- 의존성 해결
  - 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체되어야 함
  - 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부름


- 의존성 해결 방법
  1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결(스프링 DI가 해줌)
  2. 객체 생성 후 setter 메서드를 통해 의존성 해결(스프링 DI가 해줌)
  3. 메서드 실행 시 인자를 이용해 의존성 해결


## 02) 유연한 설계
- 의존성과 결합도
  - 의존성 : 두 요소 사이의 관계 유무 설명
  - 결합도 : 두 요소 사이에 존재하는 의존성의 정도를 상대적으로 표현
  - 의존성이 바람직할 때 두 요소가 느슨한 결합도 또는 약한 결합도를 가진다고 함
  - 의존성이 바람직하지 못할 때 단단한 결합 또는 강한 결합도를 가진다고 함
  - 의존성은 객체들의 협럭을 가능하게 만드는 매개체라는 관점에서 바람직하지만, 의존성이 과하면 문제가 될 수 있음


- 지식의 양과 결합도
  - 서로에 대해 알고 있는 지식의 양이 결합도를 결정함
  - 한 요소가 다른 요소에 대해 많은 정보를 알고 있을수록 강하게 결합, 반대로 적은 정보일수록 약하게 결합


- 추상화와 결합도
  - 추상화 : 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
  - 의존하는 대상이 추상적일수록 결합도는 낮아짐


- 의존 대상 구분
  - 구체 클래스 의존성
  - 추상 클래스 의존성
  - 인터페이스 의존성


- 명시적인 의존성
  - 퍼블릭 인터페이스에 의존성을 명시적으로 노출하는 것
  - 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 살펴야 하고 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 함
  - 의존성을 명시적으로 드러내면 코드를 직접 수정해야 하는 위험을 피할 수 있음 (실행 컨텍스트에서 적절한 의존성을 선택할 수 있기 때문)
  - 유연하게 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계임  


- NEW의 해로움
  - new 연산자 사용을 위해 구체 클래스 이름 직접 기술 필요. new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도가 높아짐
  - new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 함. new 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아짐  


- NEW로 인한 결합도 증가 해결 방법
  - 인스턴스를 생성하는 로직과 생서오딘 인스턴스를 사용하는 로직을 분리해서 해결할 수 있음
  - 인스턴스를 직접 생성하는 것이 아니라 해당하는 인스턴스를 전달받아(생성자, setter, 인자 등을 통해) 사용하기만 해야 함
  - 사용과 생성의 책임을 분리하고 생성하는 책임을 클라이언트로 옮김. 의존성을 생성자에 명시적으로 드러내고 구체 클래스가 아닌 추상 클래스에 의존하게 하여 설계가 유연해짐


- 가끔 생성해도 무방
  - 협력하는 기본 객체를 설정하고 싶은 경우 인스턴스를 직접 생성하는 방식이 유용한 경우도 있음
  - 기본값을 생성하는 메서드와 인스턴스를 인자로 받는 메서드를 함께 사용한다면 클래스의 사용성을 향상시키면서도 다양한 컨텍스트에서 유연하게 사용될 수 있는 여지를 제공할 수 있음 (단 이건 결합도와 사용성의 트레이드오프 이다. 구체 클래스에 의존하게 되더라도 클래스의 사용성이 더 중요하다면 결합도를 높이는 방향으로 작성할 수 있음)
  - 종종 모든 결합도가 모이는 FACTORY를 추가함으로써 사용성과 유연성 두 마리 토끼를 잡을 수 있는 경우도 있음


- 표준 클래스에 대한 의존은 해롭지 않음
  - 변경될 확률이 거의 없는 클래스라면 의존성이 문제되지 않음
  - 이런 클래스들에 대해서는 구체 클래스에 의존하거나 직접 인스턴스를 생성하더라도 문제가 없음 -> 물론 추상적인 타입을 사용하는 것이 확장성 측면에서 유리함

