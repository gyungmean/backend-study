# 객체지향 프로그래밍
## 객체지향 프로그래밍을 향해
### 협력, 객체, 클래스
클래스 ≠ 객체
### 도메인의 구조를 다르는 프로그램 구조
**도메인**이란? 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야

객체지향의 장점 : 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문
### 클래스 구현하기
```java
public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
        this.movie =  movie;
        this.sequence = sequence;
        this.whenScreened = whenScreened;
    }

    public LocalDateTime getStartTime() {
        return whenScreened;
    }

    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }

    public Money getMovieFee() {
        return move.getFee();
    }
}
```
- 인스턴스 변수 → private
- 메서드 → public  
클래스 구현, 사용에서 가장 중요한 것은 클래스의 경계를 구분 짓는 것.  
외부에서는 객체의 속성에 직접 접근할 수 없도록  
적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 해야함.

### 자율적인 객체
객체 ⇒ 상태(state) + 행동(behavior)

대부분의 객체지향 언어는 캡슐화에서 나아가서 접근을 통제할 수 있는 접근제어 메커니즘도 제공  
public, protected, private 같은 접근 수정자를 제공함

**인터페이스와 구현의 분리**원칙
- 외부에서 접근이 가능한 부분은 퍼블릭 인터페이스로
- 내부에서만 접근 가능한 부분을 구현(implementation)이라고 부른다.

### 협력하는 객체들의 공동체
```java
// Screening.java
public Reservation reserve(Customer customer, int audienceCount) {
    return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
}

private Money calculateFee(int audienceCount) {
    return movie.calculateMoveFee(this).times(audienceCount);
}
```
여기서 calculateFee가 호출하고 있는 movie의 calculateMoveFee는 1인당 요금을 반환한다.  
따라서 Screening의 calculateFee는 전체 예매 요금을 구하기 위해 audienceCount를 곱한다.  
그리고 해당 값을 다시 예매 정보를 만들기 위해 Reservation으로 전달한다.  
```java
class Money {
    public static final Money ZERO = Money.wons(0);

    private final BigDecimal amount;

    public static Money wons(long amount) {
        return new Money(BigDecimal.valueof(amount));
    }

    public static Money wons(double amount) {
        return new Money(BigDecimal.valueof(amount));
    }

    Money(BigDecimal amount) {
        this.amount = amount;
    }

    public Money plus(Money amount) {
        return new Money(this.amount.add(amount.amount));
    }

    public Money minus(Money amount) {
        return new Money(this.amount.substract(amount.amount));
    }

    public Money times(double percent) {
        return new Money(this.amount.multiply(BigDecimal.valueOf(percent)));
    }

    public boolean isLessThan(Money other) {
        return amount.compareTo(other.amount) < 0;
    }

    public boolean isGreaterThanOrEqual(Money other) {
        return amount.compareTo(other.amount) >= 0;
    }
}
```
금액을 구현하기 위해 단순히 Long타입을 사용할 수도 있지만, 위와 같이 표현함으로써  
객체를 이용해 의미를 좀 더 명시적이고 분명하게 표현할 수 있고, 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 있다.

하나의 변수만을 가지는 경우에도 굳이 객체로 만들어야 하는걸까? 라는 질문에 대해 이 책에서는
```
그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다.
```
라고 나와있다.

```java
class Reservation {
    private Customer customer;
    private Screening screening;
    private Money fee;
    private int audienceCount;

    public Reservation(Customer customer, Screening screening, Money fee, int audienceCount) {
        this.customer = customer;
        this.screening = screening;
        this.fee = fee;
        this.audienceCount = audienceCount;
    }
}
```
영화를 예매하기 위해 Screening, Movie, Reservation 인스턴스들은 서로의 메서드를 호출하며 상호작용한다.  
이런 객체들 간의 상호작용을 **협력**이라고 한다.

## 할인 요금 구하기
### 할인 요금을 구하기 위한 협력 시작하기
```java
class Movie {
    private String title;
    private Duration duration;
    private Money fee;
    private DiscountPolicy discountPolicy;
    
    public Movie(String title, Duration duration, Money fee, DiscountPolicy discountPolicy) {
        this.title = title;
        this.duration = duration;
        this.fee = fee;
        this.discountPolicy = discountPolicy;
    }
    
    public Money getFee() {
        return fee;
    }
    
    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```
할인 정책의 종류에는 일정한 금액을 할인해주는 정책과, 일정한 비율에 따라 할인을 결정하는 정책 총 두가지가 있다.  
하지만 위 Movie 코드에서는 어디에도 할인 정책의 종류를 정해주는 것이 없고,  
단지 discountPolicy에게 메시지를 전송한다.  
상속과 다형성의 개념이 적용된 사례이다.  

### 할인 정책과 할인 조건
두 할인 정책은 대부분의 코드가 유사하고 할인 요금을 계산하는 방식만 조금 다르다.  
→ 그렇기 때문에 중복 코드를 제거하고 공통 코드를 보관할 공간이 필요하다.  

부모 클래스인 DiscountPolicy를 만들고 안에 중복코드를 담는다.  
그리고 각각의 할인 정책들이 이를 상속받게 한다.  
할인 정책에 대한 인스턴스는 자식 클래스들만 생성하면 되므로 추상클래스로 구현할 수 있다.
```java
public abstract class DiscountPolicy {
    private List<DiscountPolicy> conditions = new ArrayList<>();

    public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = Arrays.asList(conditions);
    }

    public Money calculateDiscountAmount(Screening screening) {
        for(DiscountCondition each : conditions) {
            if(each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }
        return Money.zero;
    }

    abstract protected Moeny getDiscountAmount(Screening screening);
}

```
위 코드는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만  
실제로 요금을 계산하는 부분은 자식 클래스가 구현할 getDiscountAmount에게 위임한다.

이처럼 부모클래스에 기본적인 알고리즘의 흐름을 구현하고  
중간에 필요한 처리를 자식클래스에게 위임하는 디자인패턴
⇒ `**TEMPLATE METHOD**` 패턴

<details>
<summary>template method vs strategy</summary>
읽다보니 템플릿 메서드 패턴이랑 전략패턴이 비슷하게 느껴져서 차이를 정확히 정리하고 넘어가고 싶어졌다.

### template method
상위클래스(보통 abstract class)가 알고리즘의 뼈대를 정의하고,  
알고리즘의 일부 단계를 하위 클래스가 재정의.
### strategy
알고리즘을 별도 클래스들로 캡슐화하고,  
컨텍스트 객체가 그 전략을 컴포지션 하여 런타임에 전략을 교체

그렇다면 위에서 템플릿 메서드 방식으로 구현된 DiscountPolicy를 전략패턴으로 변경해본다면 어떤식으로 바꿀 수 있을까?
```java
public interface DiscountPolicy {
    Money calculateDiscountAmount(Screening screening);
}
```
먼저 인터페이스로 calculateDiscountAmount를 선언한다.
```java
public class AmountDiscountPolicy implements DiscountPolicy {
    private Money discountAmount;
    private List<DiscountCondition> conditions;

    public AmountDiscountPolicy(Money discountAmount, DiscountCondition... conditions) {
        this.discountAmount = discountAmount;
        this.conditions = Arrays.asList(conditions);
    }

    @Override
    public Money calculateDiscountAmount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return discountAmount;
            }
        }
        return Money.ZERO;
    }
}
public class AmountDiscountPolicy implements DiscountPolicy {
    private Money discountAmount;
    private List<DiscountCondition> conditions;

    public AmountDiscountPolicy(Money discountAmount, DiscountCondition... conditions) {
        this.discountAmount = discountAmount;
        this.conditions = Arrays.asList(conditions);
    }

    @Override
    public Money calculateDiscountAmount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return discountAmount;
            }
        }
        return Money.ZERO;
    }
}
```
그리고 기존에 abstract class를 상속받던 클래스들을 인터페이스의 구현체로 위와 같이 변경해본다.
```java
Movie avatar = new Movie(
    "Avatar", 
    Duration.ofMinutes(120), 
    Money.wons(10000),
    new AmountDiscountPolicy(
        Money.wons(800),
        new SequenceCondition(1),
        new SequenceCondition(10),
        new PeriodCondition(DayOfWeek.MONDAY, LocalTime.of(10, 0), LocalTime.of(11, 59)),
        new PeriodCondition(DayOfWeek.THURSDAY, LocalTime.of(10, 0), LocalTime.of(20, 59))
    )
);
```
사용은 이렇게 할 수 있고 기존 방식과 차이가 거의 없다.
하지만 코드를 살펴보면 기존에 abstract class에 있던 calculateDiscountAmount의 코드가 중복되지만  
부모 자식간의 강한 결합이 사라지고 인터페이스 기반으로 느슨한 결합이 가능해졌다.

개인적인 생각으로는 이게 바로 템플릿 메서드 → 전략 패턴 전환 시의 트레이드오프가 아닐까 라고 생각했다.
</details>

```java
public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}
```
할인 조건인 DiscountCondition은 위와같이 인터페이스로 선언되어있다.
조건에는 순번 조건과 기간 조건이라는 두 가지 할인이 있다.
이는 각각 다음과 같이 구현된다.
```java
public class SequenceCondition implements DiscountCondition {
    private int sequence;

    public SequenceCondition(int sequence) {
        this.sequence = sequence;
    }

    public boolean isSatisfiedBy(Screening screening) {
        return screening.isSequence(sequence);
    }
}

public class PeriodCondition implements DiscountCondition {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public PeriodCondition(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {
        this.dayOfWeek = dayOfWeek;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    public boolean isSatisfiedBy(Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
            startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
            endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```
그리고 이제 위에서 나왔던 abstract을 구현하는 할인 정책들을 다음과 같이 만들 수 있다.
```java
public class AmountDiscountPolicy extends DiscountPolicy {
    private Money discountAmount;

    public AmountDiscountPolicy(Money discountAmount, DiscountCondition... conditions) {
        super(conditions);
        this.discountAmount = discountAmount;
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        return discountAmount;
    }
}

public class PercentDiscountPolicy extends DiscountPolicy {
    private double percent;

    public PercentDiscountPolicy(double percent, DiscountCondition... conditions) {
        super(conditions);
        this.percent = percent;
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        return screening.getMovieFee().times(percent);
    }
}
```
### 할인 정책 구성하기
만약에 아바타라는 영화에 두개의 순서조건과 두개의 기간 조건을 가진 금액할인 정책을 적용시킨다면 다음과 같이 표현할 수 있다.

```java
Movie avatar = new Movie(
    "아바타", Money.wons(10000),
    new AmountDiscountPolicy(
        Money.wons(800), 
        new SequenceCondition(1), 
        new SequenceCondition(10),
        new PeriodCondition(DayOfWeek.MONDAY, LocalTime.of(10, 0), LocalTime.of(11, 59)),
        new PeriodCondition(DayOfWeek.THURSDAY, LocalTime.of(10, 0), LocalTime.of(20, 59))
    )
);
```
## 상속과 다형성
### 컴파일 시간 의존성과 실행 시간 의존성
어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.

`Movie` 클래스 코드에서는 `DiscountPolicy`에만 의존을 하고 있다.  
하지만 실제 영화 요금을 계산하려면 `AmountDiscountPolicy`나 `PercentDiscountPolicy`에 의존해야한다.

어떻게 Movie 인스턴스는 코드 작성 시점에서는 존재조차 몰랐던 두 인스턴스와 협력이 가능한가?  
위 아바타를 생성하던 코드를 살펴보면  
생성자에서 AmountDiscountPolicy를 인자로 전달하고 있다.  
따라서 실행 시점에 `Movie`는 `AmountDiscountPolicy` 클래스 인스턴스에 의존하게 된다.

코드 의존성 ≠ 실행 시점 의존성

코드 의존성과 실행 시점 의존성이 다르면 다를 수록 코드를 이해하기 어려워진다.  
하지만!  
이 둘이 다르면 다를 수록 코드는 더 유연해지고 확장 가능해진다.

따라서  
의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 잘 보여준다.

### 상속과 인터페이스
자식 클래스는 부모클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.
다시 한번 Movie의 코드를 보면
```java
public Money calculateMovieFee(Screening screening) {
    return fee.minus(discountPolicy.calculateDiscountAmount(screening));
}
```
Movie는 그저 calculateDiscountAmount라는 메시지를 이해할 수 있는 객체라면 그게 어떤 클래스의 인스턴스인지 상관 없다.  
이처럼 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 부른다.

### 다형성
calculateDiscountAmount라는 메시지를 보내서 실행되는 메서드는 AmountDiscountPolicy에서 오버라이딩 된 메서드일수도 있고, PercentDiscountPolicy에서 오버라이딩된 메서드 일수도 있다.  
이렇게 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메서드를 수신하는 객체에 따라 달라진다. 이를 **다형성**이라고 한다.  

다형성을 구성하는 방법은 다양하지만 
메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 **실행 시점**에 결정한다는 공통점이 있다.
이를 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)이라고 부른다.  
반대로 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것은
초기 바인딩(early binding)또는 정적 바인딩(static binding)이라고 부른다.

- 다형성을 구성하는 방법들
| 구분              | 형태               | 바인딩 시점 | 다형성 유형 | 설명                  |
| --------------- | ---------------- | ------ | ------ | ------------------- |
| **상속 + 오버라이딩**  | `extends`        | 실행 시점  | 동적 다형성 | 부모 타입으로 자식 메서드 호출   |
| **인터페이스 구현체**   | `implements`     | 실행 시점  | 동적 다형성 | 인터페이스 기반 전략 교체 가능   |
| **추상 클래스**      | `abstract class` | 실행 시점  | 동적 다형성 | 일부 공통로직 + 추상 메서드 구현 |
| **오버로딩**        | 같은 이름, 다른 매개변수   | 컴파일 시점 | 정적 다형성 | 메서드 시그니처로 결정        |
| **람다 / 익명 클래스** | 인터페이스 구현 축약형     | 실행 시점  | 동적 다형성 | 런타임 시 실제 구현체 바인딩    |


## 추상화와 유연성
### 유연한 설계
할인 정책이 없는 경우에는 어떻게 해야할까?
```java
public class Movie {
    public Money calculateMovieFee(Screening screening) {
        if(discountPolicy == null) {
            return fee;
        }
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```
위 방식의 경우 할인 정책이 null인 경우를 예외 케이스 처리하여 해결한다.  
즉, 할인 금액이 0원이라고 결정하는 책임이 DiscountPolicy가 아니라 Movie에게 있게 되는 것이다.  
이를 해결하기 위해서는 NoneDiscountPolicy라는 정책을 추가할 수 있다.
```java
public class NoneDiscountPolicy extends DiscountPolicy {
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return Money.ZERO;
    }
}
```
그렇다면 이제 할인이 적용되지 않은 영화는 다음과 같이 만들 수 있다.
```java
Movie starWars = new Movie(
    Duration.ofMinutes(210),
    Money.wons(10000),
    new NoneDiscountPolicy()
);
```
굳이 Movie 클래스에 if문을 추가하는 등 코드 변경 없이도 할인 정책의 종류를 확장했다.

### 추상 클래스와 인터페이스 트레이드오프
위에서 작성한 NoneDiscountPolicy를 자세히 살펴보면 해당 클래스안에서 오버라이딩된 getDiscountAmount는 사실 어디서도 쓰이지 않는다.  
calculateDiscountAmount에서 Condition이 있는 경우에만 해당 메서드를 호출하기 때문이다.  
이걸 해결하려면?
DiscountPolicy를 abstract class가 아니라 interface로 변경하고 calculateDiscountAmount를 오버라이딩하도록 구현하도록 변경한다.  
(위에서 전략패턴으로 변경하던 것과 유사하게)
```java
public class NoneDiscountPolicy implements DiscountPolicy {
    @Override
    public Money calculateDiscountAmount(Screening screening) {
        return Money.ZERO;
    }
}
```
어떤 설계가 과연 더 좋은 방식일지는 알 수 없다.  
구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다.

### 코드 재사용
Movie가 DiscountPolicy의 코드를 재사용하는 방법이 **합성(composition)**이다.  
코드 재사용성을 위해서는 상속보다 합성이 더 좋은 방법이라는 이유가 뭘까?

- 상속의 단점
    - 캡슐화 위반 (부모 클래스의 구현이 자식 클래스에게 노출)
    - 설계를 유연하지 못하게 만들음 (실행 시점에 객체의 종류 변경 불가능)

그렇다고 무조건적으로 합성이 더 낫다!는 아니기 때문에 상황에 따라 적절하게 사용할 수 있어야 한다.
