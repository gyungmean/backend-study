## 객체지향 프로그래밍을 향해
### 협력, 객체, 클래스
진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있음

다음의 두가지에 집중!
- 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지를 고민
- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야함


### 도메인의 구조를 다르는 프로그램 구조
문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부름
요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있음.


### 클래스 구현하기
```java
public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
        this.movie =  movie;
        this.sequence = sequence;
        this.whenScreened = whenScreened;
    }

    public LocalDateTime getStartTime() {
        return whenScreened;
    }

    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }

    public Money getMovieFee() {
        return move.getFee();
    }
}
```
인스턴스 변수 → private
메서드 → public  

클래스 구현, 사용에서 가장 중요한 것은 클래스의 경계를 구분 짓는 것.  
외부에서는 객체의 속성에 직접 접근할 수 없도록 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 해야함.

### 자율적인 객체
1. 객체는 상태와 행동을 함께 가지는 복합적인 존재임
2. 객체는 스스로 판단하고 행동하는 자율적인 존재임

객체라는 다누이 안에 데이터와 기능을 한 덩어리로 함께 묶는 것을 캡슐화라고 함.

캡슐화와 접근 제어는 객체를 두 부분으로 나누는데 하나는 외부에서 접근 가능한 부분으로 이를 퍼블릭 인터페이스라고 부르고, 
다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 구현이라고 부름.

일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야 함!


### 협력하는 객체들의 공동체
```java
// Screening.java
public Reservation reserve(Customer customer, int audienceCount) {
    return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
}

private Money calculateFee(int audienceCount) {
    return movie.calculateMoveFee(this).times(audienceCount);
}
```
여기서 calculateFee가 호출하고 있는 movie의 calculateMoveFee는 1인당 요금을 반환.  
따라서 Screening의 calculateFee는 전체 예매 요금을 구하기 위해 audienceCount를 곱하고 해당 값을 다시 예매 정보를 만들기 위해 Reservation으로 전달.  
```java
class Money {
    public static final Money ZERO = Money.wons(0);

    private final BigDecimal amount;

    public static Money wons(long amount) {
        return new Money(BigDecimal.valueof(amount));
    }

    public static Money wons(double amount) {
        return new Money(BigDecimal.valueof(amount));
    }

    Money(BigDecimal amount) {
        this.amount = amount;
    }

    public Money plus(Money amount) {
        return new Money(this.amount.add(amount.amount));
    }

    public Money minus(Money amount) {
        return new Money(this.amount.substract(amount.amount));
    }

    public Money times(double percent) {
        return new Money(this.amount.multiply(BigDecimal.valueOf(percent)));
    }

    public boolean isLessThan(Money other) {
        return amount.compareTo(other.amount) < 0;
    }

    public boolean isGreaterThanOrEqual(Money other) {
        return amount.compareTo(other.amount) >= 0;
    }
}
```
금액을 구현하기 위해 단순히 Long타입을 사용할 수도 있지만, 위와 같이 표현함으로써 객체를 이용해 의미를 좀 더 명시적이고 분명하게 표현할 수 있고, 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 있음

하나의 변수만을 가지는 경우에도 굳이 객체로 만들어야 하는걸까? 라는 질문에 대해 "그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다."라고 함

```java
class Reservation {
    private Customer customer;
    private Screening screening;
    private Money fee;
    private int audienceCount;

    public Reservation(Customer customer, Screening screening, Money fee, int audienceCount) {
        this.customer = customer;
        this.screening = screening;
        this.fee = fee;
        this.audienceCount = audienceCount;
    }
}
```
영화를 예매하기 위해 Screening, Movie, Reservation 인스턴스들은 서로의 메서드를 호출하며 상호작용하고 이를 *협력*이라고 함.

## 할인 요금 구하기
### 할인 요금을 구하기 위한 협력 시작하기
```java
class Movie {
    private String title;
    private Duration duration;
    private Money fee;
    private DiscountPolicy discountPolicy;
    
    public Movie(String title, Duration duration, Money fee, DiscountPolicy discountPolicy) {
        this.title = title;
        this.duration = duration;
        this.fee = fee;
        this.discountPolicy = discountPolicy;
    }
    
    public Money getFee() {
        return fee;
    }
    
    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```
할인 정책의 종류에는 일정한 금액을 할인해주는 정책과, 일정한 비율에 따라 할인을 결정하는 정책 총 두가지가 있다.  
하지만 위 Movie 코드에서는 어디에도 할인 정책의 종류를 정해주는 것이 없고,  
단지 discountPolicy에게 메시지를 전송한다.  
상속과 다형성의 개념이 적용된 사례이다.  

### 할인 정책과 할인 조건
두 할인 정책은 대부분의 코드가 유사하고 할인 요금을 계산하는 방식만 조금 다르다.  
→ 그렇기 때문에 중복 코드를 제거하고 공통 코드를 보관할 공간이 필요하다.  

부모 클래스인 DiscountPolicy를 만들고 안에 중복코드를 담는다.  
그리고 각각의 할인 정책들이 이를 상속받게 한다.  
할인 정책에 대한 인스턴스는 자식 클래스들만 생성하면 되므로 추상클래스로 구현할 수 있다.
```java
public abstract class DiscountPolicy {
    private List<DiscountPolicy> conditions = new ArrayList<>();

    public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = Arrays.asList(conditions);
    }

    public Money calculateDiscountAmount(Screening screening) {
        for(DiscountCondition each : conditions) {
            if(each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }
        return Money.zero;
    }

    abstract protected Moeny getDiscountAmount(Screening screening);
}

```
위 코드는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만 실제로 요금을 계산하는 부분은 자식 클래스가 구현할 getDiscountAmount에게 위임함.

이처럼 부모클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식클래스에게 위임하는 디자인패턴을 TEMPLATE METHOD 패턴이라고 함.



```java
public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}
```
할인 조건인 DiscountCondition은 위와같이 인터페이스로 선언되어 있고 순번 조건과 기간 조건이라는 두 가지 할인이 있음.
```java
public class SequenceCondition implements DiscountCondition {
    private int sequence;

    public SequenceCondition(int sequence) {
        this.sequence = sequence;
    }

    public boolean isSatisfiedBy(Screening screening) {
        return screening.isSequence(sequence);
    }
}

public class PeriodCondition implements DiscountCondition {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public PeriodCondition(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {
        this.dayOfWeek = dayOfWeek;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    public boolean isSatisfiedBy(Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
            startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
            endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```
abstract을 구현하는 할인 정책들을 다음과 같이 만들 수 있음.
```java
public class AmountDiscountPolicy extends DiscountPolicy {
    private Money discountAmount;

    public AmountDiscountPolicy(Money discountAmount, DiscountCondition... conditions) {
        super(conditions);
        this.discountAmount = discountAmount;
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        return discountAmount;
    }
}

public class PercentDiscountPolicy extends DiscountPolicy {
    private double percent;

    public PercentDiscountPolicy(double percent, DiscountCondition... conditions) {
        super(conditions);
        this.percent = percent;
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        return screening.getMovieFee().times(percent);
    }
}
```
### 할인 정책 구성하기
만약에 아바타라는 영화에 두개의 순서조건과 두개의 기간 조건을 가진 금액할인 정책을 적용시킨다면 다음과 같이 표현할 수 있음.

```java
Movie avatar = new Movie(
    "아바타", Money.wons(10000),
    new AmountDiscountPolicy(
        Money.wons(800), 
        new SequenceCondition(1), 
        new SequenceCondition(10),
        new PeriodCondition(DayOfWeek.MONDAY, LocalTime.of(10, 0), LocalTime.of(11, 59)),
        new PeriodCondition(DayOfWeek.THURSDAY, LocalTime.of(10, 0), LocalTime.of(20, 59))
    )
);
```
## 상속과 다형성
### 컴파일 시간 의존성과 실행 시간 의존성
코드의 의존성과 실행 시점의 의존성은 서로 다를 수 있음.
다시 말해 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있움. 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것임.

한 가지 간과해서는 안되는 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다는 것임. 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문임. 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해짐. 이와 같은 의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 잘 보여줌.

### 상속과 인터페이스
상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 됨. 자식 클래스는 부모클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있음.  

Movie의 코드
```java
public Money calculateMovieFee(Screening screening) {
    return fee.minus(discountPolicy.calculateDiscountAmount(screening));
}
```
Movie는 그저 calculateDiscountAmount라는 메시지를 이해할 수 있는 객체라면 그게 어떤 클래스의 인스턴스인지 상관 없음.  
이처럼 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 부름.

### 다형성
calculateDiscountAmount라는 메시지를 보내서 실행되는 메서드는 AmountDiscountPolicy에서 오버라이딩 된 메서드일수도 있고, PercentDiscountPolicy에서 오버라이딩된 메서드 일수도 있음  
이렇게 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메서드를 수신하는 객체에 따라 달라지는데 이를 *다형성*이라고 함. 

다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정해야한다는 공통점이 있음. 다시 말해 메시지와 메서드를 실행 시점에 바인딩한다는 것. 이를 지연 바인딩(lazy binding)또는 동적 바인딩(dynamic binding)이라고 부름. 그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩(early binding) 또는 정적 바인딩(static binding)이라고 부름.

## 추상화와 유연성
### 유연한 설계
할인 정책이 없는 경우에는 어떻게 해야할까?
```java
public class Movie {
    public Money calculateMovieFee(Screening screening) {
        if(discountPolicy == null) {
            return fee;
        }
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```
위 방식의 경우 할인 정책이 null인 경우를 예외 케이스 처리하여 해결함.
즉, 할인 금액이 0원이라고 결정하는 책임이 DiscountPolicy가 아니라 Movie에게 있게 되는 것임.
이를 해결하기 위해서는 NoneDiscountPolicy라는 정책을 추가할 수 있음.
```java
public class NoneDiscountPolicy extends DiscountPolicy {
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return Money.ZERO;
    }
}
```
그렇다면 이제 할인이 적용되지 않은 영화는 다음과 같이 만들 수 있음.
```java
Movie starWars = new Movie(
    Duration.ofMinutes(210),
    Money.wons(10000),
    new NoneDiscountPolicy()
);
```
굳이 Movie 클래스에 if문을 추가하는 등 코드 변경 없이도 할인 정책의 종류를 확장했음.

### 추상 클래스와 인터페이스 트레이드오프
위에서 작성한 NoneDiscountPolicy를 자세히 살펴보면 해당 클래스안에서 오버라이딩된 getDiscountAmount는 사실 어디서도 쓰이지 않음.
calculateDiscountAmount에서 Condition이 있는 경우에만 해당 메서드를 호출하기 때문임.
이걸 해결하려면?
DiscountPolicy를 abstract class가 아니라 interface로 변경하고 calculateDiscountAmount를 오버라이딩하도록 구현하도록 변경함.
(위에서 전략패턴으로 변경하던 것과 유사하게)
```java
public class NoneDiscountPolicy implements DiscountPolicy {
    @Override
    public Money calculateDiscountAmount(Screening screening) {
        return Money.ZERO;
    }
}
```
어떤 설계가 과연 더 좋은 방식일지는 알 수 없고 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있음.

### 코드 재사용
Movie가 DiscountPolicy의 코드를 재사용하는 방법이 **합성(composition)**이다.  
합성은 상속이 가지는 두 가지 문제점을 모두 해결함.
- 상속의 단점
    - 캡슐화 위반 (부모 클래스의 구현이 자식 클래스에게 노출)
    - 설계를 유연하지 못하게 만들음 (실행 시점에 객체의 종류 변경 불가능)

그렇다고 무조건적으로 합성이 더 낫다!는 아니기 때문에 상황에 따라 적절하게 사용할 수 있어야 함.