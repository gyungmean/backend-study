# 객체 분해
**인지 과부화(cognitive overload)**
</br>문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 떨어지는 현상 

**추상화**
</br>불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업(목적: 인지 과부화 방지)

**분해**
</br>큰 문제를 해결 가능한 작은 문제로 나누는 작업(목적: 추상화 방법)
하나의 단위로 취급하는 청크(chunk)

## 1. 프로시저 추상화와 데이터 추상화
**프로시저 추상화**
- 소프트웨어가 무엇을 해야하는지를 추상화
- 기능 분해(functional decomposition)= 알고리즘 분해(algorithmic decomposition)

**데이터 추상화**
- 소프트웨어가 무엇을 알아야 하는지 추상화
- 타입 추상화(type abstraction) = 추상 데이터 타입(Abstract Data Type)
- 프로시저를 추상화(procedure abstraction) = 객체지향(Object-Oriented)

<참고> ADT(Abstract Data Type, 추상 데이터 타입)와 DS(Data Structure, 데이터 구조)
</br>ADT와 DS는 밀접하게 연결되어 있으며, 종종 함께 사용됨. ADT는 어떤 데이터 타입이 수행해야 할 연산을 정의
</br>반면, 데이터 구조는 이러한 ADT가 실제로 메모리 상에서 어떻게 구현 될지를 결정함
</br>ADT는 무엇(What)을 할 것인지에 대해 정의하고, 데이터 구조는 어떻게(How)할 것인지에 대해 정의함
</br>-> ADT를 구현한 것을 DS라 볼 수있음

## 2. 프로시저 추상화와 기능 분해
**프로시저**
반복적으로 실행되거나 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화
</br>내부의 상세한 구현을 모르더라도 인터페이스만 알면 프로시저를 사용(추상화)

**하향식 접근법(Top-Down)**
</br>가장 최상위(topmost) 기능을 정의하고, 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법
트리로 표현할 수 있다. 트리에서 각 노드(node)는 시스템을 구성하는 하나의 프로시저를 의미하고 한 노드의 자식 노드는 부모 노드를 구현하는 절차 중의 한 단계를 의미한다. 
급여 관리 시스템을 트리 구조로 표현한 것이다.
<img width="700" height="400" alt="image" src="https://github.com/user-attachments/assets/ef25580e-d8e8-42e6-a68d-e72e0807484c" />
p.225
- 직원 급여 계산 시스템(main 함수) - 전역 변수 저장 직원 기본급 정보를 얻음 - 세율을 입력받음 - 이를 통해 급여를 계산함

### 하향식 기능 분해의 문제점 
1. 시스템은 하나의 메인 함수로 구성돼 있지 않다.
2. 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈버하게 수정해야 한다.
3. 비즈니스 로직이 사용 인터페이스
4. 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 재사용성이 저하된다.
5. 데이터 형식이 변경될 경우 파급효과 예측할 수 없다. 

하향식 접근이 유용할 때
- 설계가 안정화되어 있을 때 다양한 측면을 논리적으로 설명하고 문서화하기 용이함.

## 3.모듈
기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해

### 정보 은닉과 모듈
- 정보 은닉: 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다.
- 모듈: 서브 프로그램이라기보다는 책임의 할당
- 모듈화: 개별적인 모듈에 대한 작업이 시작되기 전에 정해져야 하는 설계 결정

모듈은 두 가지 비밀을 감춘다.
- 복잡성: 모듈이 너무 복잡한 경우 이해하고 사용하기가 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.
- 변경 가능성: 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.

### 모듈의 장점과 한계
**장점**
- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
- 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리
- 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다.
 
## 4.데이터 추상화와 추상 데이터 타입
### 추상 데이터 타입
- 추상 객체의 클래스 정의, 추상 객체에 사용할 수 있는 오퍼레이션 정의

추상 데이터 타입을 구현하려면 다음과 같은 특성을 위한 프로그래밍 언어의 지원이 필요하다.
- 타입 정의를 선언할 수 있어야 한다.
- 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
- 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
- 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.

## 5.클래스
### 클래스는 ADT인가?
- 클래스는 ADT라고 볼 순 없음(상속과 다형성을 지원하기 때문)
- ADT는 여러가지 타입이 공존하여 분기문을 통해서 구분(Swift에서는 Struct, enum)

### 변경을 기준으로 ADT와 클래스를 선택
- 특정 기능을 추가하기 위해
  - ADT에서는 분기문을 추가 및 관련 코드 전체를 전수검사 후 추가
  - 다형성은 새로운 타입을 추가
- 다형성의 장점은 OCP 즉 새로운 타입을 추가하기 위해 기존 코드의 수정을 필요로 하지 않음
  - 단점은 한가지 기능 추가를 위해 모든 타입에 영향이 감
- ADT의 장점은 새로운 오퍼레이션 추가시 해당 타입에만 추가하면 됨
  - 새로운 타입 추가를 위한 분기문 등 모든 코드에 영향을 준다.
- 따라서 각 장점을 참고하여 ADT를 사용할지, 다형성을 선택할지 결정하면 됨
