# 07/객체 분해

단기 기억 : 보관되어 있는 지식에 직접 접근할 수 있지만 정보를 보관할 수 있는 속도와 공간적 측면이 모두 제약을 받는다.  
장기 기억 : 경험한 내용을 수개월에서 길게는 평생에 걸쳐 보관하는 장소이다.  
-> 일반적으로 장기 기억 안에 보관되어 있는 지식은 직접 접근하는 것이 불가능하고 먼저 단기 기억 영역으로 옮긴 후에 처리해야 한다.

실제 문제를 해결하기 위해 사용하는 저장소는 단기 기억인데 문제 해결에 필요한 요소가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격히 떨어지는 인지 과부하 현상이 발생한다.

인지 과부하를 방지하기 위해 단기 기억 안에 보관할 정보의 양을 조절한다.

- 추상화
  - 문제 해결의 핵심만 남기는 작업
  - 핵심을 남기기 어렵다면, 문제의 크기를 더욱 작은 문제의 단위로 나누는 작업인 분해 실행

## 1) 프로시저 추상화와 데이터 추상화
- 프로시저 추상화 : 소프트웨어가 무엇을 해야 하는지 추상화(How)
  - 기능분해 = 알고리즘 분해
- 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지 추상화(What)
  - 데이터를 중심으로 타입을 추상화
    - 추상 데이터 타입
  - 데이터를 중심으로 프로시저를 추상화
    - 객체지향

시스템을 분해하는 방법을 결정하려면 프로시저 추상화 중심인지 데이터 추상화 중심인지 결정이 필요하다.
역할과 책임을 수행하는 객체 : 객체지향 패러다임이 이용하는 추상화
협력하는 공동체를 구성하도록 객체를 나누는 과정 : 객체지향 패러다임에서의 분해

프로그래밍 언어적인 관점에서 객체지향을 바라보는 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것이다.

## 2) 프로시저 추상화와 기능 분해
- 메인 함수로서의 시스템
  - 기능 분해의 관점에서 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해한다.

- 프로시저
  - 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다.
  - 내부의 상세한 구현 내용을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기에 추상화라고 부른다.
  - 전통적인 기능 분해 방법은 하양식 접근법을 따른다.
  
- 하향식 접근법
  - 시스템을 구성하는 가장 최상위 기능을 정의한다. (추상적인 최상위 문장을 기술)
  - 정의한 최상위 기능을 기준으로 작은 단계의 하위 기능으로 분해해가는 과정이다. (기능 분해 방법)
  - 이전 단계의 추상화 수준을 감소시켜서 모든 문장이 정제 과정을 거치면서 하나 이상의 좀 더 단순하고 구체적인 문장들의 조합으로 분해되도록 한다.(정제 단계)

- 하향식 기능 분해의 문제점
  - 시스템은 하나의 메인 함수로 구성되어 있지 않다
  - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다
  - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다
    - 사용자 인터페이스 변경이 비즈니스 로직에 영향을 받아서 변경에 불안정한 아키텍처를 낳고, 관심사 분리라는 아키텍처 설계의 목적을 달성하기 어렵다
  - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다
  - 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다
  
-> 이 모든 것을 관통하는 말인 **결합도**가 하양식 설계의 단점이라고 할 수 있음

- 하향식 기능 분해의 문제점 해결 (정보 은닉과 모듈)
  - 의존성 관리 : 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다.
  - 변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 받지 안흔ㄴ 부분을 명확하게 분리하고 잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제하자.(정보 은닉과 모듈)

- 하향식 분해가 유용한 경우
  - 설계가 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하다
  - 하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이다.
  - 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임, 특히 이미 해결된 알고리즘을 문서화하고 서술하는 데에는 훌륭한 기법

## 3) 모듈
- 시스템의 변경을 관리하는 기본적인 전략
  - 함께 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것, 기능이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것  


- 정보 은닉
  - 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다
  - 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리

- 모듈의 장점과 한계
  - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다
  - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다
  - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다

## 4) 데이터 추상화와 추상 데이터 타입
- 타입
  - 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수. 변수의 값이 어떻게 행동할 것이라는 것을 예측할 수 있게 한다

- 추상 데이터 타입을 구현하기 위해 필요한 프로그래밍 언어의 지원
  - 타입 정의를 선언할 수 있어야 한다
  - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다
  - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다
  - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다

## 4) 클래스
객체지향 프로그래밍 : 상속과 다형성 지원
객체기반 프로그래밍 : 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 패러다임
추상 데이터 타입 : 오퍼레이션을 기준으로 타입을 묶는 방법
객체지향 : 타입을 기준으로 오퍼레이션을 묶는 방법  

개방 폐쇄 원칙
  - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성
  - 객체지향 설계가 전통적인 방식에 비해 변경하고 확장하기 쉬운 구조를 설계할 수 있는 이유