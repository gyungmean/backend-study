# 설계 품질과 트레이드오프
## 데이터 중심의 영화 예매 시스템
데이터 중심의 관점에서 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다.  
책임 중심의 관점에서 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다.

객체의 상태 = 구현
구현은 불안정하기 때문에 변하기 쉽다.  
상태를 중심으로 설계하면 상태의 변경 = 인터페이스의 변경 = 해당 인터페이스에 의존하는 모든 객체의 변경으로 영향이 퍼지게 된다.  

```java
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private List<DiscountCondition> discountConditions;

    private MovieType movieType;
    private Money discountAmount;
    private double discountPercent;
}

public enum MovieType {
    AMOUNT_DISCOUNT,    // 금액 할인 정책
    PERCENT_DISCOUNT,   // 비율 할인 정책
    NONE_DISCOUNT       // 미적용
}
```
데이터 중심의 Movie 클래스의 경우 할인조건의 목록과 할인정책을 Movie안에 직접 정의한다.  
MovieType이 AMOUNT_DISCOUNT인 경우 discountAmount를 PERCENT_DISCOUNT인 경우 discountPercent를 사용하는 방식으로 사용한다.

```java
public class DiscountCondition {
    private DiscountConditionType type;

    private int sequence;

    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;
}
public enum DiscountConditionType {
    SEQUENCE,       // 순번조건
    PERIOD          // 기간 조건
}
public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;
}

public class Reservation {
    private Customer customer;
    private Screening screening;
    private Money fee;
    private int audienceCount;
}
@AllArgsConstructor
public class Customer {
    private String name;
    private String id;
}
```
### 영화를 예매하자
위에서 데이터 중심으로 설계된 클래스들을 가지고 영화를 예매하기 위해서
`ReservationAgency`를 구현한다.
```java
public class ReservationAgency {
    public Reservation reserve(Screening screening, Customer customer,
                               int audienceCount) {
        Movie movie = screening.getMovie();

        boolean discountable = false;
        for(DiscountCondition condition : movie.getDiscountConditions()) {
            if (condition.getType() == DiscountConditionType.PERIOD) {
                discountable = screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek()) &&
                        condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&
                        condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) >= 0;
            } else {
                discountable = condition.getSequence() == screening.getSequence();
            }

            if (discountable) {
                break;
            }
        }

        Money fee;
        if (discountable) {
            Money discountAmount = Money.ZERO;
            switch(movie.getMovieType()) {
                case AMOUNT_DISCOUNT:
                    discountAmount = movie.getDiscountAmount();
                    break;
                case PERCENT_DISCOUNT:
                    discountAmount = movie.getFee().times(movie.getDiscountPercent());
                    break;
                case NONE_DISCOUNT:
                    discountAmount = Money.ZERO;
                    break;
            }

            fee = movie.getFee().minus(discountAmount).times(audienceCount);
        } else {
            fee = movie.getFee().times(audienceCount);
        }

        return new Reservation(customer, screening, fee, audienceCount);
    }
}
```
## 설계 트레이드오프
### 캡슐화
변경될 가능성이 높은 부분을 **구현** 이라고 한다.  
상대적으로 안정적인 부분을 **인터페이스**라고 부른다.

캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다.

객체 내부에 무엇을 캡슐화 해야하는가?  
변경될 수 있는 어떤 것이라도 캡슐화해야 한다.
### 응집도와 결합도
- 응집도 : 모듈에 포함된 내부 요소들이 연관돼 있는 정도
- 결합도 : 의존성의 정도를 나타냄.

일반적으로 좋은 설계는 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.

변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.  
즉, 하나의 변경이 일어날때 모듈 전체가 변경된다면 응집도가 높은 것  
모듈의 일부만 변경된다면 응집도가 낮은 것.

또, 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높은 것  
다수의 모듈이 함께 변경된다면 응집도가 낮은 것.

반대로 결합도 역시 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도로 알 수 있다.

결합도가 높아도 상관 없는 경우?
변경될 확률이 매우 적은 안정적인 모듈일 경우 가능하다.
예를 들어 자바의 `String`이나 `ArrayList`  
그러나 직접 작성한 코드의 경우 항상 불안정하며 언제라도 변경될 가능성이 있다.  
버그가 있을 수도 있고 요구사항이 변경될 수도 있다.  
따라서 결합도를 낮게 유지하는 것이 좋은 설계가 된다.

## 데이터 중심의 영화 예매 시스템의 문제점
- 캡슐화 위반
- 높은 결합도
- 낮은 응집도
### 캡슐화 위반
Movie의 fee를 변경 시키거나 접근하기 위해서는 `getFee`, `setFee`를 사용해야한다.  
직접 fee에 접근하는 것은 아니기 때문에 캡슐화 원칙을 지키는 것 처럼 보이지만
Movie내부에 fee라는 인스턴스 변수가 존재하는 사실을 퍼블릭 인터페이스로 노출하는 것.

이렇게 접근자와 수정자에게 과도하게 의존하는 설계 방식을
추측에 의한 설계 전략 이라고 부른다.

### 높은 결합도
`ReservationAgency`를 살펴보면 한 명의 예매 요금을 계산하기 위해서 Movie의 `getFee`를 호출한다.  
만약 fee의 타입이 변경될 경우 `getFee`를 사용하고 있는 모든 부분의 변경이 함께 일어나야한다.

뿐만 아니라 `ReservationAgency`는 다양한 객체에 의존하고 있기 때문에  
어떤 객체의 변경도 `ReservationAgency`의 변경을 유발한다.

### 낮은 응집도
새로운 할인 정책을 추가하거나 새로운 할인 조건을 추가하기 위해서는  
하나 이상의 클래스를 동시에 수정해야 한다.

## 자율적인 객체를 향해
### 캡슐화를 지켜라
단순히 변수의 가시성을 private으로 설정했어도 접근자와 수정자를 통해 속성을 외부로 공개하고 있다면 캡슐화를 위반하는 것.
### 스스로 자신의 데이터를 책임지는 객체
- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
```java
public class DiscountCondition {
    private DiscountConditionType type;

    private int sequence;

    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public DiscountCondition(int sequence){
        this.type = DiscountConditionType.SEQUENCE;
        this.sequence = sequence;
    }

    public DiscountCondition(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime){
        this.type = DiscountConditionType.PERIOD;
        this.dayOfWeek= dayOfWeek;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    public DiscountConditionType getType() {
        return type;
    }

    public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) {
        if (type != DiscountConditionType.PERIOD) {
            throw new IllegalArgumentException();
        }

        return this.dayOfWeek.equals(dayOfWeek) &&
                this.startTime.compareTo(time) <= 0 &&
                this.endTime.compareTo(time) >= 0;
    }

    public boolean isDiscountable(int sequence) {
        if (type != DiscountConditionType.SEQUENCE) {
            throw new IllegalArgumentException();
        }

        return this.sequence == sequence;
    }
}
```
`isDiscountable` 메서드를 통해서 할인 조건을 충족 여부를 DiscountCondition이 직접 확인할 수 있다.
즉 스스로를 책임진다고 말할 수 있다.

## 하지만 여전히 부족하다
### 캡슐화 위반
위의 `isDiscountable(DayOfWeek dayOfWeek, LocalTime time)` 메서드를 보면  
메서드 시그니처로 DiscountCondition에 DayOfWeek 타입의 dayOfWeek와 LocalTime타입의 time이 인스턴스 변수로  포함되었다는 사실을 알 수 있다.  
만약 이런 속성들이 변경된다면 isDiscountable을 사용하던 모든 클라이언트들도 수정이 필요하게 된다.  
이런 파급 효과는 캡슐화가 부족하다는 증거다.

## 데이터 중심 설계의 문제점
- 데이터 중심 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨채 오퍼레이션을 결정한다.

