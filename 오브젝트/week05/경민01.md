# 객체, 설계
## 무엇이 문제인가
`모듈`이란 크기와 상관 없이 클래스나 패키지, 라이브러리와 가팅 프로그램을 구성하는 임의의 요소를 으미한다.

소프트웨어 모듈의 목적
- 실행 중에 제대로 동작하는 것
- 변경을 위해 존재하는 것
- 코드를 읽는 사람과 의사소통 하는 것

### 예상을 빗나가는 코드
```java
public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```
enter 메서드가 동작하기 위해서는
- `Audience`가 `Bag`을 가지고 있고
- `Bag`안에는 `현금`과 `티켓`이 들어있으며
- `TicketSeller`가 `TicketOffice`에서 티켓을 판매하고
- `TicketOffice`안에 `돈`과 `티켓`이 보관되어 있다 

는 사실을 모두 알고 있어야 한다.

즉, 문제는
⇒ 하나의 클래스, 메서드에서 너무 많은 세부사항을 다룬다.  
⇒ `Audience`와 `TicketSeller`를 변경할 경우 `Theater`도 함께 변경해야한다.

### 변경에 취약한 코드
의존성은 변경에 대한 영향을 암시한다.  
즉, 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경 될 수 있다.

객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체이기 때문에  
필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거해야한다.

객체 사이의 의존성이 과한 경우를 가리켜 **결합도**(coupling)가 높다고 말한다.

따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야한다.

## 설계 개선하기
관람객이 가방을 가지고 있다는 사실과  
판매원이 매표소에서 티켓을 판매해야한다는 사실은  
Theater가 알아야할 필요가 없다.  
⇒ 관람객과 판매원을 **자율적인 존재**로 만들어야 한다.

### 자율성을 높이자
첫 번째 단계  
`Theater`의 `enter메서드`에서 `TicketOffice`에 접근하는 모든 코드를 `TicketSeller`내부로 숨긴다.
```java
public class TicketSeller {
    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketOffice.getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketOffice.getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketOffice.plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```
기존 TicketSeller와 다르게 `getTicketOffice`가 제거되었다.  
따라서 해당 TicketOffice에는 오직 TicketSeller만이 접근가능하다.  

객체 내부의 세부적인 사항을 감추는 것을 **캡슐화**라고 부른다.

이제 Theater의 enter메서드는 sellTo를 호출하는 코드로 변경된다.
```java
public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);
    }
}
```
Theater는 TicketSeller내부에 TicketOffice가 있다는 사실을 알 수 없다.  
Theater는 오직 TicketSeller의 인터페이스에만 의존한다.

TicketSeller는 여전히 Audience에 의존적이기 때문에 같은 방법으로 제거한다.  
Audience의 getBag()하는 로직을 제거하면 Audience의 캡슐화를 개선할 수 있다.
```java
public class Audience {
    private Bag bag;
    
    public Audience(Bag bag) {
        this.bag = bag;
    }
    
    public Long buy(Ticket ticket) {
        if(bag.hasInvitation()) {
            bag.setTicket(ticket);
            return 0L;
        } else {
            bag.setTicket(ticket);
            bag.minusAmount(ticket.getFee());
            return ticket.getFee();
        }
    }
}
```
관람객은 스스로 가방에 초대장이 있는지 확인한다.  
외부의 제3자가 자신의 가방을 열어보도록 허용하지 않고
외부 객체들은 관람객이 가방을 가지고 있는지 없는지 알 수 없다.
```java
public class TicketSeller {
    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Audience audience) {
        ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));
    }
}
```