# 객체, 설계

## 무엇이 문제인가

모듈이란 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미

소프트웨어 모듈의 목적
- 실행 중에 제대로 동작하는 것
- 변경을 위해 존재하는 것 
- 코드를 읽는 사람과 의사소통 하는 것

이해 가능한 코드는 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드.

변경에 취약한 코드는 많은 객체 사이의 의존성(변경에 대한 영향을 암시)이 있는 코드지만 객체 사이의 의존성을 완전히 없애는 것이 정답은 아님.

객체 지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이기에 우리의 목표는 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것.

-> 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야 함.

### 예상을 빗나가는 코드

```java
public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```

하나의 클래스, 메서드에서 너무 많은 세부사항을 다루며 `Audience`와 `TicketSeller`를 변경할 경우 `Theater`도 함께 변경해야 한다는 점이 문제.



### 변경에 취약한 코드

의존성은 변경에 대한 영향을 암시한다.  
즉, 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경 될 수 있다.

객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체이기 때문에  
필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거해야한다.

객체 사이의 의존성이 과한 경우를 가리켜 **결합도**(coupling)가 높다고 말한다.

따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야한다.

## 설계 개선하기

관람객이 가방을 가지고 있다는 사실과  
판매원이 매표소에서 티켓을 판매해야한다는 사실은  
Theater가 알아야할 필요가 없다.  
⇒ 관람객과 판매원을 **자율적인 존재**로 만들어야 한다.

### 자율성을 높이자

첫 번째 단계  
`Theater`의 `enter메서드`에서 `TicketOffice`에 접근하는 모든 코드를 `TicketSeller`내부로 숨김

```java
public class TicketSeller {
    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketOffice.getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketOffice.getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketOffice.plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```

기존 TicketSeller와 다르게 `getTicketOffice`가 제거되어 TicketOffice에는 오직 TicketSeller만이 접근가능

객체 내부의 세부적인 사항을 감추는 것을 *캡슐화*라고 부름.

객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙임.


Theater의 enter메서드는 sellTo를 호출하는 코드로 변경함

```java
public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);
    }
}
```

Theater는 TicketSeller내부에 TicketOffice가 있다는 사실을 알 수 없고 Theater는 TicketSeller의 인터페이스에만 의존

TicketSeller는 여전히 Audience에 의존적이기 때문에 같은 방법으로 제거함

Audience의 getBag()하는 로직을 제거하면 Audience의 캡슐화를 개선할 수 있음

```java
public class Audience {
    private Bag bag;

    public Audience(Bag bag) {
        this.bag = bag;
    }

    public Long buy(Ticket ticket) {
        if(bag.hasInvitation()) {
            bag.setTicket(ticket);
            return 0L;
        } else {
            bag.setTicket(ticket);
            bag.minusAmount(ticket.getFee());
            return ticket.getFee();
        }
    }
}
```

관람객은 스스로 가방에 초대장이 있는지 확인하고 외부의 제3자가 자신의 가방을 열어보도록 허용하지 않고 외부 객체들은 관람객이 가방을 가지고 있는지 없는지 알 수 없음.

```java
public class TicketSeller {
    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Audience audience) {
        ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));
    }
}
```

연관된 작업만 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 `응집도`가 높다고 함. 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을 뿐더러 응집도를 높일 수 있음.

### 더 개선할 수 있다

`Audience`는 `Bag`에 의존하고 있기 때문에 다음과 같이 수정할 수 있음.

```java
public class Bag {
    private Long amount;
    private Ticket ticket;
    private Invitation invitation;

    public Long hold(Ticket ticket) {
        if (hasInvitation()) {
            setTicket(ticket);
            return 0L;
        } else {
            setTicket(ticket);
            minusAmount(ticket.getFee());
            return ticket.getFee();
        }
    }

    private void setTicket(Ticket ticket) {
        this.ticket = ticket;
    }

    private boolean hasInvitation() {
        return invitation != null;
    }

    private void minusAmount(Long amount) {
        this.amount -= amount;
    }
}

public class Audience {
    private Bag bag;

    public Audience(Bag bag) {
        this.bag = bag;
    }

    public Long buy(Ticket ticket) {
        return bag.hold(ticket);
    }
}
```

`TicketSeller` 역시 `TicketOffice`의 자율성을 침해하기에 아래와 같이 수정 가능

```java
public class TicketOffice {
    private Long amount;
    private List<Ticket> tickets = new ArrayList<>();

    public TicketOffice(Long amount, Ticket... tickets) {
        this.amount = amount;
        this.tickets.addAll(Arrays.asList(tickets));
    }

    public void sellTicketTo(Audience audience) {
        plusAmount(audience.buy(getTicket()));
    }

    private Ticket getTicket() {
        return tickets.remove(0);
    }

    private void plusAmount(Long amount) {
        this.amount += amount;
    }
}

public class TicketSeller {
    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Audience audience) {
        ticketOffice.sellTicketTo(audience);
    }
}
```

하지만 변경된 이후에 `TicketOffice`는 `Audience`에 대한 의존성이 추가됐음


어떤 것을 우선해야하는가? (트레이드 오프! -> 선택이 필요함)
- 어떤 기능을 설계하는 방법은 한 가지 이상
- 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물임
- 따라서 어떤 경우에도 모든 사람들을 만족 시킬 수 있는 설계는 할 수 없음

의인화
- 사실 위의 객체들은 실세계에서 자율적인 존재가 아님. 따라서 우리가 세상을 바라보는 직관과 일치하지 않음
- 현실에서는 수동적인 존재라도 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀜
- 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킴

### 객체지향 설계
좋은 설계
- 우리가 짜는 프로그램의 두 가지 요구사항
  - 오늘 완성해야 하는 기능을 구현하는 코드를 짜야한다.
  - 내일 쉽게 변경할 수 있는 코드를 짜야 한다.
- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계이다.
  - 개발을 시작하는 시점에 구현에 필요한 모든 요구사항을 수집하는 것은 불가능에 가깝다. → 개발이 진행되는 동안 요구사항은 바뀔 수밖에 없다.
  - 코드를 수정하지 않는다면 버그는 발생하지 않는다. 코드를 변경할 때 버그가 추가될 가능성이 높기 때문에 설계가 중요하다.


객체지향 설계
- 우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드이다.
- 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공한다. → 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높혀준다.
- 1장에서 나온 얘기인 데이터와 프로세스를 하나의 덩어리로 모으는 것은 훌륭한 객체지향 설계로 가는 첫걸음일 뿐이다. 진정한 객체지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것이다.


